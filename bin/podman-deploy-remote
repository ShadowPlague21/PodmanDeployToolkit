#!/bin/bash

# podman-deploy-remote: The remote-side deployment companion.
# Runs on the target server to complete the deployment process.

# --- Safety First ---
set -e
set -u
set -o pipefail

# --- Configuration ---
# The script is expected to be run from the staging directory
STAGING_DIR=$(pwd)
SERVICE_NAME=${1:-}

# --- Helper Functions ---
print_status() {
    echo -e "\033[1;34m>>> $1\033[0m"
}

print_success() {
    echo -e "\033[1;32m‚úÖ $1\033[0m"
}

print_error() {
    echo -e "\033[1;31m‚ùå Error: $1\033[0m"
}

# --- Main Logic ---

if [ -z "$SERVICE_NAME" ]; then
    print_error "No service name provided."
    echo "Usage: podman-deploy-remote <service-name>"
    exit 1
fi

# 0. Pre-flight check: Verify systemd user session
if ! systemctl --user list-units --no-legend > /dev/null 2>&1; then
    print_error "Unable to access 'systemctl --user'. The systemd user instance is not active."
    print_status "This is common on fresh servers or when SSHing as a user without lingering enabled."
    print_status "To fix this, run the following command as ROOT on the server:"
    echo "   loginctl enable-linger $USER"
    print_status "Then try deploying again."
    exit 1
fi

print_status "Starting remote deployment for '${SERVICE_NAME}'..."

# Check for required files
if [ ! -f "${SERVICE_NAME}.tar" ] || [ ! -f "${SERVICE_NAME}.container" ]; then
    print_error "Required files not found in staging directory: ${SERVICE_NAME}.tar or ${SERVICE_NAME}.container"
    print_status "Current directory contents:"
    ls -la
    exit 1
fi

# 1. Load the Podman image
print_status "Loading the Podman image from ${SERVICE_NAME}.tar..."
podman load -i "${SERVICE_NAME}.tar"

# 2. Find and install the Quadlet file to the correct location
QUADLET_DIR="${HOME}/.config/containers/systemd"
mkdir -p "$QUADLET_DIR"

print_status "Installing ${SERVICE_NAME}.container to ${QUADLET_DIR}..."
cp "${SERVICE_NAME}.container" "$QUADLET_DIR/"

# 3. THIS IS THE KEY FIX:
# Let systemd discover and process the Quadlet file. Do NOT use podman generate systemd.
print_status "Reloading systemd user configuration..."
systemctl --user daemon-reload

# 4. Dynamically find the generated service unit name
# Quadlet files like 'my-app.container' generate units like 'my-app.service'
# This is more robust than hardcoding the name.
UNIT_NAME="${SERVICE_NAME}.service"

# 5. Enable and start the service
print_status "Enabling and starting the ${UNIT_NAME} service..."
systemctl --user enable "$UNIT_NAME"
systemctl --user start "$UNIT_NAME"

# 6. Verify the service is running
print_status "Verifying the service is running..."
sleep 5  # Give the service a moment to start

if systemctl --user is-active --quiet "$UNIT_NAME"; then
    print_success "‚úÖ Service '${UNIT_NAME}' is running successfully!"
    
    # Show the service status
    print_status "Service status:"
    systemctl --user status "$UNIT_NAME"
    
    # Show container logs using journalctl (Source of Truth for Quadlet)
    print_status "Recent service logs:"
    journalctl --user -u "$UNIT_NAME" -n 20 --no-pager || echo "Could not retrieve logs"
else
    print_error "Service '${UNIT_NAME}' failed to start properly."
    print_status "Service status:"
    systemctl --user status "$UNIT_NAME" || echo "Could not get status"
    
    # Show container logs for debugging
    print_status "Service logs:"
    journalctl --user -u "$UNIT_NAME" -n 50 --no-pager || echo "Could not retrieve logs"
    
    echo
    echo "================================================================="
    echo "‚ö†Ô∏è  DEPLOYMENT FAILED - MANUAL ROLLBACK INSTRUCTIONS"
    echo "================================================================="
    echo "To revert changes, run the following commands manually:"
    echo
    echo "1. Stop and disable the broken service:"
    echo "   systemctl --user stop ${UNIT_NAME}"
    echo "   systemctl --user disable ${UNIT_NAME}"
    echo
    echo "2. Remove the Quadlet definition:"
    echo "   rm ${QUADLET_DIR}/${SERVICE_NAME}.container"
    echo
    echo "3. Reload systemd:"
    echo "   systemctl --user daemon-reload"
    echo "================================================================="
    
    exit 1
fi

# 7. Cleanup staging directory (optional - could be kept for debugging)
read -p "Clean up staging directory? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    print_status "Cleaning up staging directory..."
    cd ..
    rm -rf "${STAGING_DIR}"
    print_success "Staging directory cleaned up."
else
    print_status "Keeping staging directory for potential debugging."
fi

print_success "üéâ Deployment of '${SERVICE_NAME}' completed successfully on the remote server!"
echo
echo "Useful commands:"
echo "  Check service status: systemctl --user status ${UNIT_NAME}"
echo "  View logs:          journalctl --user -u ${UNIT_NAME} -f"
echo "  Restart service:    systemctl --user restart ${UNIT_NAME}"
echo "  Stop service:       systemctl --user stop ${UNIT_NAME}"