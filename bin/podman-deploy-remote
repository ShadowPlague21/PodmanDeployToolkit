#!/bin/bash

# podman-deploy-remote: The remote-side deployment companion.
# Runs on the target server to complete the deployment process.

# --- Safety First ---
set -e
set -u
set -o pipefail

# --- Configuration ---
# The script is expected to be run from the staging directory
STAGING_DIR=$(pwd)
SERVICE_NAME=${1:-}

# --- Helper Functions ---
print_status() {
    echo -e "\033[1;34m>>> $1\033[0m"
}

print_success() {
    echo -e "\033[1;32m‚úÖ $1\033[0m"
}

print_error() {
    echo -e "\033[1;31m‚ùå Error: $1\033[0m"
}

# --- Main Logic ---

if [ -z "$SERVICE_NAME" ]; then
    print_error "No service name provided."
    echo "Usage: podman-deploy-remote <service-name>"
    exit 1
fi

print_status "Starting remote deployment for '${SERVICE_NAME}'..."

# Check for required files
if [ ! -f "${SERVICE_NAME}.tar" ] || [ ! -f "${SERVICE_NAME}.container" ]; then
    print_error "Required files not found in staging directory: ${SERVICE_NAME}.tar or ${SERVICE_NAME}.container"
    print_status "Current directory contents:"
    ls -la
    exit 1
fi

# 1. Load the Podman image
print_status "Loading the Podman image from ${SERVICE_NAME}.tar..."
podman load -i "${SERVICE_NAME}.tar"

# 2. Find and install the Quadlet file to the correct location
QUADLET_DIR="${HOME}/.config/containers/systemd"
mkdir -p "$QUADLET_DIR"

print_status "Installing ${SERVICE_NAME}.container to ${QUADLET_DIR}..."
cp "${SERVICE_NAME}.container" "$QUADLET_DIR/"

# 3. THIS IS THE KEY FIX:
# Let systemd discover and process the Quadlet file. Do NOT use podman generate systemd.
print_status "Reloading systemd user configuration..."
systemctl --user daemon-reload

# 4. Dynamically find the generated service unit name
# Quadlet files like 'my-app.container' generate units like 'my-app.service'
# This is more robust than hardcoding the name.
UNIT_NAME="${SERVICE_NAME}.service"

# 5. Enable and start the service
print_status "Enabling and starting the ${UNIT_NAME} service..."
systemctl --user enable "$UNIT_NAME"
systemctl --user start "$UNIT_NAME"

# 6. Verify the service is running
print_status "Verifying the service is running..."
sleep 5  # Give the service a moment to start

if systemctl --user is-active --quiet "$UNIT_NAME"; then
    print_success "‚úÖ Service '${UNIT_NAME}' is running successfully!"
    
    # Show the service status
    print_status "Service status:"
    systemctl --user status "$UNIT_NAME"
    
    # Show container logs
    print_status "Recent container logs:"
    podman logs --tail 10 "${SERVICE_NAME}" || echo "Could not retrieve logs"
else
    print_error "Service '${UNIT_NAME}' failed to start properly."
    print_status "Service status:"
    systemctl --user status "$UNIT_NAME" || echo "Could not get status"
    
    # Show container logs for debugging
    print_status "Container logs:"
    podman logs --tail 20 "${SERVICE_NAME}" || echo "Could not retrieve logs"
    
    exit 1
fi

# 7. Cleanup staging directory (optional - could be kept for debugging)
read -p "Clean up staging directory? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    print_status "Cleaning up staging directory..."
    cd ..
    rm -rf "${STAGING_DIR}"
    print_success "Staging directory cleaned up."
else
    print_status "Keeping staging directory for potential debugging."
fi

print_success "üéâ Deployment of '${SERVICE_NAME}' completed successfully on the remote server!"
echo
echo "Useful commands:"
echo "  Check service status: systemctl --user status ${UNIT_NAME}"
echo "  View logs:          journalctl --user -u ${UNIT_NAME} -f"
echo "  Restart service:    systemctl --user restart ${UNIT_NAME}"
echo "  Stop service:       systemctl --user stop ${UNIT_NAME}"